<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://zhmhhu.github.io/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://zhmhhu.github.io">
<meta name="author" content="zhmhhu">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">
<!-- 用户自定义的样式 -->
<link rel="stylesheet" href="/css/myStyle.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>【译】再看 flask 视频流 - 赵小生的博客</title>

<meta name="keywords" content="">

<meta name="description " content="这篇文章讲述了一个在树莓派上运行的更加实用的、高效的 Flask 视频流程序。">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="博">博</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>
        <a href="/tags" title="标签"><i class="fa fa-tags"></i><span>标签</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/help" title="帮助">
            <i class="fa fa-question-circle"></i>
            <span>帮助</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">赵小生的博客</h1>
        <h3 class="cover-siteTitle">传播科技，关注人文</h3>
        <p class="cover-siteDesc">写更少的代码，过更好的生活</p>
        <div class="cover-sns">
            
            <div class="btn btn-weibo">
                <a href="https://weibo.com/zhmhhu" target="_blank" title="weibo" ref="friend">
                    <i class="fa fa-weibo"></i>
                </a>
            </div>
            
            <div class="btn btn-twitter">
                <a href="https://twitter.com/zhmhhu" target="_blank" title="twitter" ref="friend">
                    <i class="fa fa-twitter"></i>
                </a>
            </div>
            
            <div class="btn btn-github">
                <a href="https://github.com/zhmhhu" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
            
                <li class="">
                    <a href="/categories/coding" data-name="代码">代码</a>
                </li>
            
                <li class="">
                    <a href="/categories/technology" data-name="科技">科技</a>
                </li>
            
                <li class="">
                    <a href="/categories/design" data-name="设计">设计</a>
                </li>
            
                <li class="">
                    <a href="/categories/talk" data-name="杂谈">杂谈</a>
                </li>
            
                <li class="">
                    <a href="/categories/resource" data-name="资源">资源</a>
                </li>
            
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">请输入关键字</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="请输入关键字" />
        <button type="submit" class="search-form-submit" title="搜索"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div><img width="100%" src="https://blog.miguelgrinberg.com/static/images/video-streaming-revisited.jpg" alt="photos"/></div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="https://github.com/zhmhhu" target="_blank">
                    <img width="48" src="/images/userpic.jpg" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="https://github.com/zhmhhu" target="_blank">赵小生</a>
                    <span title="最后编辑于2019-01-07">2019-01-07</span>
                </p>
                <p>不会讲故事的程序员不是好的水利工程师</p>
            </div>
            <h2 class="post-title">【译】再看 Flask 视频流</h2>
            <div class="post-meta">
                本文总共9062个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <blockquote>
<ul>
<li>原文地址：<a href="https://blog.miguelgrinberg.com/post/flask-video-streaming-revisited" target="_blank" rel="noopener">Flask Video Streaming Revisited</a></li>
<li>原文作者：<a href="https://blog.miguelgrinberg.com" target="_blank" rel="noopener">Miguel Grinberg</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/flask-video-streaming-revisited.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/flask-video-streaming-revisited.md</a></li>
<li>译者：<a href="https://github.com/zhmhhu" target="_blank" rel="noopener">zhmhhu</a></li>
<li>校对者：</li>
</ul>
</blockquote>
<h1 id="再看-Flask-视频流"><a href="#再看-Flask-视频流" class="headerlink" title="再看 Flask 视频流"></a>再看 Flask 视频流</h1><p><img src="https://blog.miguelgrinberg.com/static/images/video-streaming-revisited.jpg" alt=""></p>
<p>大约三年前，我在这个名为 <a href="https://juejin.im/post/5bea86fc518825158c531e9c" target="_blank" rel="noopener">Video Streaming with Flask</a> 的博客上写了一篇文章，其中我提出了一个非常实用的流媒体服务器，它使用 Flask 生成器视图函数将 <a href="https://en.wikipedia.org/wiki/Motion_JPEG" target="_blank" rel="noopener">Motion-JPEG</a>  流传输到 Web 浏览器。在那片文章中，我的意图是展示简单而实用的<a href="http://flask.pocoo.org/docs/0.12/patterns/streaming/" target="_blank" rel="noopener">流式响应</a>，这是 Flask 中一个不为人知的特性。</p>
<p>那篇文章非常受欢迎，倒并不是因为它教会了读者如何实现流式响应，而是因为很多人都希望实现流媒体视频服务器。不幸的是，当我撰写文章时，我的重点不在于创建一个强大的视频服务器所以我经常收到读者的提问及寻求建议的请求，他们想要将视频服务器用于实际应用程序，但很快发现了它的局限性。</p>
<h2 id="回顾：使用-Flask-的视频流"><a href="#回顾：使用-Flask-的视频流" class="headerlink" title="回顾：使用 Flask 的视频流"></a>回顾：使用 Flask 的视频流</h2><p>我建议您阅读<a href="https://blog.miguelgrinberg.com/post/video-streaming-with-flask" target="_blank" rel="noopener">原始文章</a>以熟悉我的项目。简而言之，这是一个 Flask 服务器，它使用流式响应来提供从 Motion JPEG 格式的摄像机捕获的视频帧流。这种格式非常简单，虽然并不是最有效的，它具有以下优点：所有浏览器都原生支持它，无需任何客户端脚本。出于这个原因，它是安防摄像机使用的一种相当常见的格式。为了演示服务器，我使用相机模块为树莓派编写了一个相机驱动程序。对于那些没有没有树莓派，只有手持相机的人，我还写了一个模拟的相机驱动程序，它可以传输存储在磁盘上的一系列 jpeg 图像。</p>
<h2 id="仅在有观看者时运行相机"><a href="#仅在有观看者时运行相机" class="headerlink" title="仅在有观看者时运行相机"></a>仅在有观看者时运行相机</h2><p>人们不喜欢的原始流媒体服务器的一个原因是，当第一个客户端连接到流时，从树莓派的摄像头捕获视频帧的后台线程就开始了，但之后它永远不会停止。处理此后台线程的一种更有效的方法是仅在有查看者的情况下使其运行，以便在没有人连接时可以关闭相机。</p>
<p>我刚刚实施了这项改进。这个想法是，每次客户端访问视频帧时，都会记录该访问的当前时间。相机线程检查此时间戳，如果发现它超过十秒，则退出。通过此更改，当服务器在没有任何客户端的情况下运行十秒钟时，它将关闭其相机并停止所有后台活动。一旦客户端再次连接，线程就会重新启动。</p>
<p>以下是对这项改进的简要说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Camera(object):</span><br><span class="line">    # ...</span><br><span class="line">    last_access = 0  # 最后一个客户端访问相机的时间</span><br><span class="line"></span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    def get_frame(self):</span><br><span class="line">        Camera.last_access = time.time()</span><br><span class="line">        # ...</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def _thread(cls):</span><br><span class="line">        with picamera.PiCamera() as camera:</span><br><span class="line">            # ...</span><br><span class="line">            for foo in camera.capture_continuous(stream, &apos;jpeg&apos;, use_video_port=True):</span><br><span class="line">                # ...</span><br><span class="line">                # 如果没有任何客户端访问视屏帧</span><br><span class="line">                # 10 秒钟之后停止线程</span><br><span class="line">                if time.time() - cls.last_access &gt; 10:</span><br><span class="line">                    break</span><br><span class="line">        cls.thread = None</span><br></pre></td></tr></table></figure>
<h2 id="简化相机类"><a href="#简化相机类" class="headerlink" title="简化相机类"></a>简化相机类</h2><p>很多人向我提到的一个常见问题是很难添加对其他相机的支持。我为树莓派实现的 <code>Camera</code> 类相当复杂，因为它使用后台捕获线程与相机硬件通信。</p>
<p>为了使它更容易，我决定将对于帧的所有后台处理的通用功能移动到基类，只留下从相机获取帧以在子类中实现的任务。模块 <code>base_camera.py</code> 中的新 <code>BaseCamera</code> 类实现了这个基类。以下是这个通用线程的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BaseCamera(object):</span><br><span class="line">    thread = None  # 从摄像机读取帧的后台线程</span><br><span class="line">    frame = None  # 后台线程将当前帧存储在此</span><br><span class="line">    last_access = 0  # 最后一个客户端访问摄像机的时间</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def frames():</span><br><span class="line">        &quot;&quot;&quot;Generator that returns frames from the camera.&quot;&quot;&quot;</span><br><span class="line">        raise RuntimeError(&apos;Must be implemented by subclasses.&apos;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def _thread(cls):</span><br><span class="line">        &quot;&quot;&quot;Camera background thread.&quot;&quot;&quot;</span><br><span class="line">        print(&apos;Starting camera thread.&apos;)</span><br><span class="line">        frames_iterator = cls.frames()</span><br><span class="line">        for frame in frames_iterator:</span><br><span class="line">            BaseCamera.frame = frame</span><br><span class="line"></span><br><span class="line">            # 如果没有任何客户端访问视屏帧</span><br><span class="line">            # 10 秒钟之后停止线程</span><br><span class="line">            if time.time() - BaseCamera.last_access &gt; 10:</span><br><span class="line">                frames_iterator.close()</span><br><span class="line">                print(&apos;Stopping camera thread due to inactivity.&apos;)</span><br><span class="line">                break</span><br><span class="line">        BaseCamera.thread = None</span><br></pre></td></tr></table></figure>
<p>这个新版本的树莓派的相机线程使用了另一个生成器而变得通用了。线程期望 <code>frames()</code> 方法（这是一个静态方法）成为一个生成器，这个生成器在特定的不同摄像机的子类中实现。迭代器返回的每个项目必须是 jpeg 格式的视频帧。</p>
<p>以下展示的是返回静态图像的模拟摄像机如何适应此基类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Camera(BaseCamera):</span><br><span class="line">    &quot;&quot;&quot;模拟相机的实现过程，将</span><br><span class="line">     文件1.jpg，2.jpg和3.jpg形成的重复序列以每秒一帧的速度以流式文件的形式传输。&quot;&quot;&quot;</span><br><span class="line">    imgs = [open(f + &apos;.jpg&apos;, &apos;rb&apos;).read() for f in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]]</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def frames():</span><br><span class="line">        while True:</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            yield Camera.imgs[int(time.time()) % 3]</span><br></pre></td></tr></table></figure>
<p>注意在这个版本中，<code>frames()</code>生成器如何通过简单地在帧之间休眠来形成每秒一帧的速率。</p>
<p>通过重新设计，树莓派相机的相机子类也变得更加简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import io</span><br><span class="line">import picamera</span><br><span class="line">from base_camera import BaseCamera</span><br><span class="line"></span><br><span class="line">class Camera(BaseCamera):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def frames():</span><br><span class="line">        with picamera.PiCamera() as camera:</span><br><span class="line">            # let camera warm up</span><br><span class="line">            time.sleep(2)</span><br><span class="line"></span><br><span class="line">            stream = io.BytesIO()</span><br><span class="line">            for foo in camera.capture_continuous(stream, &apos;jpeg&apos;, use_video_port=True):</span><br><span class="line">                # return current frame</span><br><span class="line">                stream.seek(0)</span><br><span class="line">                yield stream.read()</span><br><span class="line"></span><br><span class="line">                # reset stream for next frame</span><br><span class="line">                stream.seek(0)</span><br><span class="line">                stream.truncate()</span><br></pre></td></tr></table></figure>
<h2 id="OpenCV-相机驱动"><a href="#OpenCV-相机驱动" class="headerlink" title="OpenCV 相机驱动"></a>OpenCV 相机驱动</h2><p>很多用户抱怨他们无法访问配备相机模块的树莓派，因此除了模拟相机之外，他们无法尝试使用此服务器。现在添加相机驱动程序要容易得多，我想要一个基于 <a href="http://opencv.org/" target="_blank" rel="noopener">OpenCV</a> 的相机，它支持大多数 USB 网络摄像头和笔记本电脑相机。这是一个简单的相机驱动程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">from base_camera import BaseCamera</span><br><span class="line"></span><br><span class="line">class Camera(BaseCamera):</span><br><span class="line">    @staticmethod</span><br><span class="line">    def frames():</span><br><span class="line">        camera = cv2.VideoCapture(0)</span><br><span class="line">        if not camera.isOpened():</span><br><span class="line">            raise RuntimeError(&apos;Could not start camera.&apos;)</span><br><span class="line"></span><br><span class="line">        while True:</span><br><span class="line">            # 读取当前帧</span><br><span class="line">            _, img = camera.read()</span><br><span class="line"></span><br><span class="line">            # 编码成一个 jpeg 图片并且返回</span><br><span class="line">            yield cv2.imencode(&apos;.jpg&apos;, img)[1].tobytes()</span><br></pre></td></tr></table></figure>
<p>使用此类，将使用您系统检测到的第一台摄像机。如果您使用的是笔记本电脑，这可能是您的内置摄像头。如果要使用此驱动程序，则需要为 Python 安装 OpenCV 绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install opencv-python</span><br></pre></td></tr></table></figure>
<h2 id="相机选择"><a href="#相机选择" class="headerlink" title="相机选择"></a>相机选择</h2><p>该项目现在支持三种不同的摄像头驱动程序：模拟、树莓派和 OpenCV。为了更容易选择使用哪个驱动程序而不必编辑代码，Flask 服务器查找 <code>CAMERA</code> 环境变量以了解要导入的类。此变量可以设置为 <code>pi</code> 或 <code>opencv</code>，如果未设置，则默认使用模拟摄像机。</p>
<p>实现它的方式非常通用。无论 <code>CAMERA</code> 环境变量的值是什么，服务器都希望驱动程序位于名为 <code>camera_ $ CAMERA.py</code> 的模块中。服务器将导入该模块，然后在其中查找 <code>Camera</code>类。逻辑实际上非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from importlib import import_module</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line"># import camera driver</span><br><span class="line">if os.environ.get(&apos;CAMERA&apos;):</span><br><span class="line">    Camera = import_module(&apos;camera_&apos; + os.environ[&apos;CAMERA&apos;]).Camera</span><br><span class="line">else:</span><br><span class="line">    from camera import Camera</span><br></pre></td></tr></table></figure>
<p>例如，要从 bash 启动 OpenCV 会话，你可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CAMERA=opencv python app.py</span><br></pre></td></tr></table></figure>
<p>使用 Windows 命令提示符，你可以执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ set CAMERA=opencv</span><br><span class="line">$ python app.py</span><br></pre></td></tr></table></figure>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>在另外几次观察中，我们发现服务器消耗了大量的 CPU。其原因在于后台线程捕获帧与将这些帧回送到客户端的生成器之间没有同步。两者都尽可能快地运行，而不考虑另一方的速度。</p>
<p>通常，后台线程尽可能快地运行是有道理的，因为你希望每个客户端的帧速率尽可能高。但是你绝对不希望向客户端提供帧的生成器以比生成帧的相机更快的速度运行，因为这意味着将重复的帧发送到客户端。虽然这些重复项不会导致任何问题，但它们除了增加 CPU 和网络负载之外没有任何好处。</p>
<p>因此需要一种机制，通过该机制，生成器仅将原始帧传递给客户端，并且如果生成器内的传送回路比相机线程的帧速率快，则生成器应该等待直到新帧可用，所以它应该自行调整以匹配相机速率。另一方面，如果传送回路以比相机线程更慢的速率运行，那么它在处理帧时永远不应该落后，而应该跳过某些帧以始终传递最新的帧。听起来很复杂吧？</p>
<p>我想要的解决方案是，当新帧可用时，让相机线程信号通知生成器运行。然后，生成器可以在它们传送下一帧之前等待信号时阻塞。在查看同步单元时，我发现 <a href="https://docs.python.org/3.6/library/threading.html#event-objects" target="_blank" rel="noopener">threading.Event</a> 是匹配此行为的函数。所以，基本上每个生成器都应该有一个事件对象，然后摄像机线程应该发出信号通知所有活动事件对象，以便在新帧可用时通知所有正在运行的生成器。生成器传递帧并重置其事件对象，然后等待它们再次进行下一帧。</p>
<p>为了避免在生成器中添加事件处理逻辑，我决定实现一个自定义事件类，该事件类使用调用者的线程 id 为每个客户端线程自动创建和管理单独的事件。说实话，这有点复杂，但这个想法来自于 Flask 的上下文局部变量是如何实现的。新的事件类称为 <code>CameraEvent</code>，并具有 <code>wait()</code>、<code>set()</code> 和 <code>clear()</code> 方法。在此类的支持下，可以将速率控制机制添加到 <code>BaseCamera</code> 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class CameraEvent(object):</span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">class BaseCamera(object):</span><br><span class="line">    # ...</span><br><span class="line">    event = CameraEvent()</span><br><span class="line"></span><br><span class="line">    # ...</span><br><span class="line"></span><br><span class="line">    def get_frame(self):</span><br><span class="line">        &quot;&quot;&quot;返回相机的当前帧.&quot;&quot;&quot;</span><br><span class="line">        BaseCamera.last_access = time.time()</span><br><span class="line"></span><br><span class="line">        # wait for a signal from the camera thread</span><br><span class="line">        BaseCamera.event.wait()</span><br><span class="line">        BaseCamera.event.clear()</span><br><span class="line"></span><br><span class="line">        return BaseCamera.frame</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def _thread(cls):</span><br><span class="line">        # ...</span><br><span class="line">        for frame in frames_iterator:</span><br><span class="line">            BaseCamera.frame = frame</span><br><span class="line">            BaseCamera.event.set()  # send signal to clients</span><br><span class="line"></span><br><span class="line">            # ...</span><br></pre></td></tr></table></figure>
<p>在 <code>CameraEvent</code> 类中完成的魔法操作使多个客户端能够单独等待新的帧。<code>wait()</code> 方法使用当前线程 id 为每个客户端分配单独的事件对象并等待它。<code>clear()</code> 方法将重置与调用者的线程 id 相关联的事件，以便每个生成器线程可以以它自己的速度运行。相机线程调用的 <code>set()</code> 方法向分配给所有客户端的事件对象发送信号，并且还将删除未提供服务的任何事件，因为这意味着与这些事件关联的客户端已关闭，客户端本身也不存在了。您可以在 <a href="https://github.com/miguelgrinberg/flask-video-streaming/blob/master/base_camera.py" target="_blank" rel="noopener">GitHub 仓库</a>中看到 <code>CameraEvent</code> 类的实现。</p>
<p>为了让您了解性能改进的程度，请看一下，模拟相机驱动程序在此更改之前消耗了大约 96％ 的 CPU，因为它始终以远高于每秒生成一帧的速率发送重复帧。在这些更改之后，相同的流消耗大约 3％ 的CPU。在这两种情况下，都只有一个客户端查看视频流。OpenCV 驱动程序从单个客户端的大约 45％ CPU 降低到 12％，每个新客户端增加约 3％。</p>
<h2 id="部署-Web-服务器"><a href="#部署-Web-服务器" class="headerlink" title="部署 Web 服务器"></a>部署 Web 服务器</h2><p>最后，我认为如果您打算真正使用此服务器，您应该使用比 Flask 附带的服务器更强大的 Web服务器。一个很好的选择是使用 Gunicorn：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install gunicorn</span><br></pre></td></tr></table></figure>
<p>有了 Gunicorn，您可以按如下方式运行服务器（请记住首先将 <code>CAMERA</code> 环境变量设置为所选的摄像头驱动程序）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gunicorn --threads 5 --workers 1 --bind 0.0.0.0:5000 app:app</span><br></pre></td></tr></table></figure>
<p><code>--threads 5</code> 选项告诉 Gunicorn 最多处理五个并发请求。这意味着设置了这个值之后，您最多可以同时拥有五个客户端来观看视频流。<code>--workers 1</code> 选项将服务器限制为单个进程。这是必需的，因为只有一个进程可以连接到摄像头以捕获帧。</p>
<p>您可以增加一些线程数，但如果您发现需要大量线程，则使用异步框架比使用线程可能会更有效。可以将 Gunicorn 配置为使用与 Flask 兼容的两个框架：gevent 和 eventlet。为了使视频流服务器能够使用这些框架，相机后台线程还有一个小的补充：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class BaseCamera(object):</span><br><span class="line">    # ...</span><br><span class="line">   @classmethod</span><br><span class="line">    def _thread(cls):</span><br><span class="line">        # ...</span><br><span class="line">        for frame in frames_iterator:</span><br><span class="line">            BaseCamera.frame = frame</span><br><span class="line">            BaseCamera.event.set()  # send signal to clients</span><br><span class="line">            time.sleep(0)</span><br><span class="line">            # ...</span><br></pre></td></tr></table></figure>
<p>这里唯一的变化是在摄像头捕获循环中添加了 <code>sleep（0）</code>。这对于 eventlet 和 gevent ß都是必需的，因为它们使用协作式多任务处理。这些框架实现并发的方式是让每个任务通过调用执行网络 I/O 的函数或显式执行以释放 CPU。由于此处没有 I/O，因此执行 sleep 函数以实现释放 CPU 的目的。</p>
<p>现在您可以使用 gevent 或 eventlet worker 运行 Gunicorn，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ CAMERA=opencv gunicorn --worker-class gevent --workers 1 --bind 0.0.0.0:5000 app:app</span><br></pre></td></tr></table></figure>
<p>这里的 <code>--worker-class gevent</code> 选项配置 Gunicorn 使用 gevent 框架（你必须用<code>pip install gevent</code>安装它）。如果你愿意，也可以使用 <code>--worker-class eventlet</code>。如上所述，<code>--workers 1</code> 限制为单个处理过程。Gunicorn 中的 eventlet 和 gevent workers 默认分配了一千个并发客户端，所以这应该超过了这种服务器能够支持的客户端数量。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>上述所有更改都包含在 <a href="https://github.com/miguelgrinberg/flask-video-streaming" target="_blank" rel="noopener">GitHub仓库</a> 中。我希望你通过这些改进以获得更好的体验。</p>
<p>在结束之前，我想提供有关此服务器的其他问题的快速解答：</p>
<ul>
<li><p>如何设定服务器以固定的帧速率运行？配置您的相机以该速率传送帧，然后在相机传送回路的每次迭代期间休眠足够的时间以便以该速率运行。</p>
</li>
<li><p>如何提高帧速率？我在此描述的服务器，以尽可能快的速率提供视频帧。如果您需要更好的帧速率，可以尝试将相机配置成更小的视频帧。</p>
</li>
</ul>
<p>如何添加声音？那真的很难。Motion JPEG 格式不支持音频。你将需要使用单独的流传输音频，然后将音频播放器添加到HTML页面。即使你设法完成了所有的操作，音频和视频之间的同步也不会非常准确。</p>
<p>如何将流保存到服务器上的磁盘中？只需将 JPEG 文件的序列保存在相机线程中即可。为此，你可能希望移除在没有查看器时结束后台线程的自动机制。</p>
<p>如何将播放控件添加到视频播放器？ Motion JPEG 不允许用户进行交互式操作，但如果你想要这个功能，只需要一点点技巧就可以实现播放控制。如果服务器保存所有 jpeg 图像，则可以通过让服务器一遍又一遍地传送相同的帧来实现暂停。当用户恢复播放时，服务器将必须提供从磁盘加载的“旧”图像，因为现在用户处于 DVR 模式而不是实时观看流。这可能是一个非常有趣的项目！</p>
<p>以上就是本文的所有内容。如果你有其他问题，请告诉我们！</p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">标签：
            
            <a href="/tags/python/">python</a>
            
        </div>
        

        <div class="post-nav">
            
              
              <div class="post-nav-next post-nav-item">上一篇：
                <a href="/coding/2018-12-26-step-by-step-building-smart-robot-1-md.html" >手把手教你打造智能语音机器人（1）-强大的 DuerOS 系统</a>
              </div>
            
        </div>
    </article>
    
    <p>本文代表个人观点，内容仅供参考。若有不恰当之处，望不吝赐教！评论需科学上网才可查看！</p>
    
    
<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    var disqus_config = function () {
        this.page.url = 'http://zhmhhu.github.io/coding/2019-01-07-flask-video-streaming-revisited-md.html';
        this.page.identifier = 'coding/2019-01-07-flask-video-streaming-revisited-md.html';
    };
    (function () { // DON'T EDIT BELOW THIS LINE
        var d = document, disqus_shortname = 'zhmhhu', s = d.createElement('script');
        s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
        Disqus.</a></noscript>

</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="关于本站">关于本站</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        
<!-- Tencent Analytics -->
<script type="text/javascript" src="//tajs.qq.com/stats?sId=65912398" charset="UTF-8"></script>


    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '12/24/2017',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>
